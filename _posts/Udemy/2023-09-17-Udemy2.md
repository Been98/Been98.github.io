---
title : "[유데미x스나이퍼팩토리] 10주 완성 프로젝트 캠프 - 유니티(Unity) 기초 학습 2주차"
excerpt : "학습일지"

categories:
    - Udemy

tags:
    - Udemy
    - Unity
    - 스나이퍼팩토리
    - 부트캠프
last_modified_at : 2023-09-18
---

유데미 x 스나이퍼팩토리 10주 완성 프로젝트 캠프 - 유니티 기초 학습 2주차 내용이다.<br>

## 월요일 수업

오늘은 팩맨 게임을 만들어 보는 시간을 가졌다<br>

![image](https://github.com/Been98/Been98.github.io/assets/85021523/ae44236f-6271-4315-bcbf-81f90a233eab)
<br>

먼저 움직임 코드이다.
```C#
    Vector3 dir = new Vector3(
    Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));
    if (dir.sqrMagnitude > 0.01f)
    {
    Vector3 forward = Vector3.Slerp(transform.forward, dir,
    rotationSpeed * Time.deltaTime / Vector3.Angle(transform.forward, dir));
    transform.LookAt(transform.position + forward);
    }
    charCtrl.Move(dir * moveSpeed * Time.deltaTime);
```
<br>
1주차 포스팅에서 움직임을 다뤘는데 움직이는 코드를 하나 더 알아둬야겠다.

우선 `CharacterController` 클래스에 대해서 알아보자
`CharacterController`는 Rigidbody 물리를 활용하지 않는 3인 또는 1인 플레이어에 주로 사용이 됩니다. <br>
이 말은 즉 `CharacterController`로 캐릭터의 움직임을 구현한다면 물리적 요소는 직접 코딩으로 구현해줘야 한다는 소리이다.<br>

그렇다면 무조건 Rigidbody을 이용한 이동이 간편한거 아닌가 ? 할 수 있겠지만,
RigidBody는 성능 문제가 발생할 수 있다. 물리 연산은 성능의 무리를 주는 경우가 있어서 최적화 하는 방법을 모르고 막 사용 하다 치명적인 문제를 만들 수 있다.<br>

따라서 상황에 맞게 Rigidbody를 사용한 움직임을 사용할지 CharacterController를 사용한 움직임을 사용할지 개발자 원하는대로 하면 된다.

다음은 sqrMagnitude이다. 이 함수는 두 점간의 거리의 제곱에 루트를 한 값으로 두 점간의 거리의 차이를 2차원 함수값으로 계산해준다.
물론 Vector3.Distance를 사용하면 바로 거리를 알 수 있지만 Distance는 sqr에 비해 연산속도가 느리며 쓸데 없는 계산을 해서이다. <br>
정교한 값을 구할때는 Distance를 사용하고 2D게임을 만들거나 단순하게 두 점간의 거리를 구할땐 sqrMagnitude가 낫다.<br>

다음은 Vector3.Slerp이다. 백터 이동에서 수학적으로 다루어진 Lerp(선형 보간)과 Slerp(구면 선형 보간)이 있는데 간단하게 설명하자면  Lerp(선형 보간)는 그려진 가상의 호에서의 직선 거리, Slerp(구면 선형 보간)는 그려진 가상의 호를 그대로의 거리라고 이해하면 좋을 것 같다.<br><br>
[참고- 선형 보간과 구면 선형 보간](https://nobilitycat.tistory.com/entry/%EC%84%A0%ED%98%95-%EB%B3%B4%EA%B0%84%EA%B3%BC-%EA%B5%AC%EB%A9%B4-%EC%84%A0%ED%98%95-%EB%B3%B4%EA%B0%84slerp)
<br><br>
따라서 위 코드를 설명하자면 움직임이 인지되면 구면 선형 보간을 이용해 forward값을 정하고 LookAt을 이용하여 해당 위치를 바라보고 Move를 통해 이동한다.

```C#
    anim.SetFloat("Speed", charCtrl.velocity.magnitude);
```
<br>
위에서 언급한 sqrMagnitude와 같은 기능을 하지만 차이점은 sqrMag는 정확성이 상대적으로 낮지만 성능이 좋고 Mag는 정확성이 높지만 상대적으로 성능이 낮다.
<br>
그 후 애니메이션을 다루는 법을 상세히 배웠다.<br>

그 다음 도트를 바닥에 배치해 도트를 먹으면 승리하거나 패배하는 씬을 만들었다. <br>
또 적을 만들어 게임의 난이도를 올렸다.<br><br>
씬 전환같은 경우에는 1주차에 올렸으니 이번에는 적의 이동을 구현하는 Navigation에 대해 알아보자 ! <br><br>
Navigation은 Ai의 이동에 필요하며 어떤 한 지점에서 다른 지점으로 이동하는 길을 알려주는 역할을 한다. 물론 그냥 이동이라면 코드로 간단하게 적어서 움직일 수 있지만 장애물들이 존재하는 맵이라면 꼭 필요한 기능이다. 너무 잘 설명이 되어있는 블로그를 발견해서 올린다. 다시 사용할 일이 있다면 다시 공부하고 사용해야겠다.<br><br>
[참고 - 네비게이션] (https://wergia.tistory.com/224)
<br><br>
```C#
    agent.destination = target.transform.position;
```
그 후 Update문에 저 코드를 넣으면 적이 계속해서 플레이어 위치를 따라 최적의 길로 올 것이다.<br>

요약은 이정도로 하고 과제로는 3가지가 있었다.
1. 다양한 구조물로 새로운 맵을 만들기
2. 여러단계의 스테이지를 만들어 보기
3. 누적 점수를 표현해 보기

사실 1번과 2번은 너무 간단하기 때문에 따로 요약할게 없어보이고 3번을 얘기를 적어야겠다.
3번을 해결하는 방법으로는 많은 방법이 있다고 생각한다. 오브젝트를 만들어 dontdestroyonload를 사용하거나 싱글톤을 만들거나 등등 근데 여기서 사용한 방법은 static키워드이다.<br>

`static`키워드는 정적을 의미한다. 객체를 생성하지 않고도 멤버에 접글할 수 있게 만드는 키워드로 클래스, 필드, 메서드 등에 붙여서 static 멤버로 만들 수 있다.
즉 변할 일이 없고 객체와 상관없는 필드나 메소드에 사용이 가능하다.<br>

`static`은 선언하는 즉시 데이터에 저장이 된다.(런타임 이전에 이미 생성) 그리고 종료까지 쭉 가지고 있게 된다. 따라서 GC가 실행되지 않기 때문에 메모리 낭비가 심하기에 잘 생각하고 사용해야 겠다. 
<br>
월요일 요약 끝 ! 

## 수요일 수업

수요일 수업은 유니티짱으로 가위바위보를 하는 게임을 만들었다.

우선 화면 이동을 구현했다.
```C#
// 기본 위치 저장
    defPosition = target.transform.position;
    defRotation = target.transform.rotation;
    defZoom = Camera.main.fieldOfView;
    // 왼쪽 드래그로 카메라 이동
    if (Input.GetMouseButton(0))
    {
    target.transform.Translate(
    -Input.GetAxis("Mouse X") / 10,
    Input.GetAxis("Mouse Y") / 10,
    0);
    }
    // 오른쪽 드래그로 카메라 회전
    if (Input.GetMouseButton(1))
    {
    target.transform.Rotate(
    -Input.GetAxis("Mouse Y") * 10,
    -Input.GetAxis("Mouse X") * 10,
    0);
    }
    // 휠 회전으로 확대/축소
    if (Input.GetAxis("Mouse ScrollWheel") != 0)
    {
    Camera.main.fieldOfView += (20 * Input.GetAxis("Mo
    use ScrollWheel"));
    if (Camera.main.fieldOfView < 10)
    Camera.main.fieldOfView = 10;
    else if (Camera.main.fieldOfView > 100)
    Camera.main.fieldOfView = 100;
    }
    // 휠 클릭으로 설정 초기화
    if (Input.GetMouseButton(2))
    {
    target.transform.position = defPosition;
    target.transform.rotation = defRotation;
    Camera.main.fieldOfView = defZoom;
    }
```
<br>
우선 해당 코드의 설명은 주석에 있다.
딱히 어려운건 없지만 fieldOfView를 알아보도록 하자 
`fieldOfView`는 해석하자면 사람의 시야라고 할 수 있다.
유니티에서는 Camera.main.fieldOfView로 카메라의 시야를 뜻한다.
즉 카메라의 시야를 조정해서 줌 인과 줌 아웃을 구현한 예이다.<br>
그래픽스 수업에서 배운 기억이 있어서 정리를 하면<br>
- 낮은 fov
1. 카메라에 보이는 좌우폭이 좁다.
2. 상대적으로 사물이 가까워 보인다.
3. 왜곡이 적다.
4. 정면으로 이동시 속도감이 떨어진다.
반면에 높은 fov는 낮은 fov와 정 반대이다.

다음은 DateTime 클래스의 멤버를 알아보자
```C#
    System.DateTime dt = System.DateTime.Now; // 현재
    dt.Year; // 년
    dt.Month; // 월
    dt.Day; // 일
    dt.Hour; // 시
    dt.Minute; // 분
    dt.Second; // 초
    dt.Millisecond; // 밀리초
    dt.DayOfWeek == System.DayOfWeek.Monday; // 요일
```
이렇게 구성이 되어 있으니 잘 기억하고 사용해야겠다.

다음은 PlayerPrefs 클래스의 사용이다.
```C#
    PlayerPrefs.DeleteKey("str"); // 해당 키의 값을 삭제
    PlayerPrefs.DeleteAll(); // 모든 값을 삭제
    PlayerPrefs.SetFloat("f_num", 1.23f); // 실수 기록
    float f_num = PlayerPrefs.GetFloat("f_num"); // 실수 얻기
    PlayerPrefs.SetInt("i_num", 123); // 정수 기록
    int i_num = PlayerPrefs.GetInt("i_num"); // 정수 얻기
    PlayerPrefs.SetString("str","abc"); // 문자열 기록
    string str = PlayerPrefs.GetString("str"); // 문자열 얻기
    PlayerPrefs.Save(); // 지금 당장 변경사항 저장
```

PlayerPrefs는 유니티에서 제공해주는 데이터 관리 클래스이다.
PlayerPrefs는 현장실습에서 다뤘던 기억이 있다. 
그때는 게임 내 데이터들을 Json형태로 저장했었다.<br>
그때 기억으로는 정말 간단하게 데이터를 저장할 수 있지만 보안상 문제로 중요 데이터를 저장하고 사용하지 않는다고 배웠다.

다음은 음성 파일 재상하기를 배웠다.
AudioSource와 AudioClip에 대해서 먼저 알아보자 !<br>
AudioSource는 음악 재생기 AudioClip은 재생시킬곡을 뜻한다.
음원만 있다고 재생할 수 없고 기기만 있다고 재생할 수 없기에 둘 다 필요한 요소이다.<br>

변수 선언 후 AudioSource 컴포넌트를 추가하고 GetComponent로 해당 컴포넌트의 기능을 사용하면 된다.
실습에서 사용한 함수는 PlayOneShot()이다. Play()와 다르게 여러개의 파일을 재생하고 싶을 때 사용한다.<br>




본 후기는 유데미-스나이퍼팩토리 10주 완성 프로젝트캠프 학습 일지 후기로 작성 되었습니다.
#프로젝트캠프 #프로젝트캠프후기 #유데미 #udemy #스나이퍼팩토리 #웅진씽크빅 #인사이드아웃 #IT개발캠프 #개발자부트캠프 #unity #유니티 #게임개발 #메타버스 